'''
map:
    It is a map representing the obstables and free space for a self-driving car. 
    It is generated by the ultrasonic sensor reading values. The map is an NxN 
    matrix, and the car originally sits on coordinate (N/2, 0). Specifically,
    1 represents the place is blocked by obstacles, 0 represents free space.

'''
import numpy as np
import matplotlib.pyplot as plt

class CarMap:
    def __init__(self, size=101, visualize=False) -> None:
        '''
        Inputs:
            size:       - Dimension of the map is (size, size)
            visualize:  - Whether to visualize the map, if true, all the previous map will be saved
        '''
        self.size = size
        self.map = np.zeros((size, size), dtype=np.uint8)
        self.visualize = visualize
        self.all_maps = None

    def reset(self) -> None:
        '''
        Clear the map for reconstruction.
        '''
        if self.visualize:
            self.__save()
        self.map = np.zeros((self.size, self.size), dtype=np.uint8)

    def constructMap(self, scanlist) -> None:
        '''
        Construct the map using a full scanlist from the ultrasonic sensor.
        '''
        da = 180.0 / (len(scanlist)-1)      # delta angle
        prev_point = None
        curr_point = None
        for i, dist in enumerate(scanlist):
            curr_point = self.__getIndex(dist, -90.0 + i * da)
            if curr_point == [-1, -1]:
                prev_point = None
                continue
            if not prev_point is None:
                self.__connect(prev_point, curr_point)
            prev_point = curr_point

    def extendMap(self, width=2) -> None:
        '''
        Extend the map with given length. The extend process with repeat (width-1) times.
        '''
        if width <= 1:
            return
        for _ in range(width-1):
            for i in range(self.size):
                for j in range(self.size):
                    if self.map[i][j] == 1:
                        if i > 0:
                            self.map[i-1][j] = 2 if self.map[i-1][j] == 0 else self.map[i-1][j]
                        if i < self.size - 1:
                            self.map[i+1][j] = 2 if self.map[i+1][j] == 0 else self.map[i+1][j]
                        if j > 0:
                            self.map[i][j-1] = 2 if self.map[i][j-1] == 0 else self.map[i][j-1]
                        if j < self.size - 1:
                            self.map[i][j+1] = 2 if self.map[i][j+1] == 0 else self.map[i][j+1]
            for i in range(self.size):
                for j in range(self.size):
                    if self.map[i][j] == 2:
                        self.map[i][j] = 1

    def getMap(self):
        return self.map

    def getSource(self):
        return (self.size//2, 0)

    def printMap(self) -> None:
        '''
        Visualize the map.
        '''
        self.map[self.size//2][0] = 2
        plt.imshow(self.map)
        plt.show()
        self.map[self.size//2][0] = 0

    def __connect(self, point1, point2) -> None:
        '''
        Connect/Interpolate two obstacle points.
        '''
        dx = point2[0] - point1[0]
        dy = point2[1] - point1[1]
        length = np.sqrt(dx**2 + dy**2)
        dx /= length
        dy /= length
        curr_point = point1
        step = 0.2      # step through 0.2 length on the line connected the two points
        i = 0
        while i * step < length:
            if curr_point[0] < 0 or int(curr_point[0]) >= self.size or curr_point[1] < 0 or int(curr_point[1]) >= self.size:
                break
            self.map[int(curr_point[0])][int(curr_point[1])] = 1
            curr_point[0] += step * dx
            curr_point[1] += step * dy
            i += 1
        self.map[int(point2[0])][int(point2[1])] = 1

    def __getIndex(self, distance, angle):
        '''
        Calculate the x, y index of the point with certain distance and angle. 
        The angle ranges from -90 degree (left of the car) and 90 degree (right of the car).
        '''
        sign = 1 if angle > 0 else -1
        angle = abs(angle)
        x, y = int(distance * np.sin(angle * np.pi / 180)), int (distance * np.cos(angle * np.pi / 180))
        x = self.size // 2 + (sign * x)
        # Check whether the point go out of the boundary
        if x < 0 or x >= self.size or y >= self.size:
            return [-1, -1]
        return [x, y]

    def __save(self) -> None:
        '''
        Save the current map for visualization.
        '''
        if self.all_maps is None:
            self.all_maps = np.expand_dims(self.map, axis=0)
        else:
            self.all_maps = np.vstack((self.all_maps, np.expand_dims(self.map, axis=0)))
