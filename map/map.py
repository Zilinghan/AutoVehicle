'''
map:
    It is a map representing the obstables and free space for a self-driving car. 
    It is generated by the ultrasonic sensor reading values. The map is an NxN 
    matrix, and the car originally sits on coordinate (N/2, 0). Specifically,
    1 represents the place is blocked by obstacles, 0 represents free space.

'''
import cv2
import numpy as np
import matplotlib.pyplot as plt

class CarMap:
    def __init__(self, size=101, visualize=False) -> None:
        '''
        Inputs:
            size:       - Dimension of the map is (size, size)
            visualize:  - Whether to visualize the map, if true, all the previous map will be saved
        '''
        self.size = size
        self.map = np.zeros((size, size), dtype=np.uint8)
        print(self.map.dtype)
        self.visualize = visualize
        self.all_maps = None

    def reset(self) -> None:
        '''
        Clear the map for reconstruction.
        '''
        if self.visualize:
            self.__save()
        self.map = np.zeros((self.size, self.size), dtype=np.uint8)

    def constructMap(self, scanlist) -> None:
        '''
        Construct the map using a full scanlist from the ultrasonic sensor.
        '''
        da = 180.0 / (len(scanlist)-1)      # delta angle
        prev_point = None
        curr_point = None
        for i, dist in enumerate(scanlist):
            curr_point = self.__getIndex(dist, -90.0 + i * da)
            if curr_point == [-1, -1]:
                prev_point = None
                continue
            if not prev_point is None:
                self.__connect(prev_point, curr_point)
            prev_point = curr_point

    def printMap(self) -> None:
        '''
        Visualize the map.
        '''
        plt.imshow(self.map)
        plt.show()


    def getVideo(self, output='output.mp4', fps=1) -> None:
        '''
        TODO:
        Visualize a list of maps as a video.
        '''
        # if self.all_maps is not None:
        #     out = cv2.VideoWriter(output, cv2.VideoWriter_fourcc(*'mp4v'), fps, (self.size, self.size), False)
        #     for i in range(len(self.all_maps)):
        #         out.write(self.all_maps[i]*255)
        #     out.release()
        pass

    def __connect(self, point1, point2) -> None:
        '''
        Connect/Interpolate two obstacle points.
        '''
        dx = point2[0] - point1[0]
        dy = point2[1] - point1[1]
        length = np.sqrt(dx**2 + dy**2)
        dx /= length
        dy /= length
        curr_point = point1
        step = 0.2      # step through 0.2 length on the line connected the two points
        i = 0
        while i * step < length:
            if curr_point[0] < 0 or int(curr_point[0]) >= self.size or curr_point[1] < 0 or int(curr_point[1]) >= self.size:
                break
            self.map[int(curr_point[0])][int(curr_point[1])] = 1
            curr_point[0] += step * dx
            curr_point[1] += step * dy
            i += 1
        self.map[int(point2[0])][int(point2[1])] = 1

    def __getIndex(self, distance, angle):
        '''
        Calculate the x, y index of the point with certain distance and angle. 
        The angle ranges from -90 degree (left of the car) and 90 degree (right of the car).
        '''
        sign = 1 if angle > 0 else -1
        angle = abs(angle)
        x, y = int(distance * np.sin(angle * np.pi / 180)), int (distance * np.cos(angle * np.pi / 180))
        x = self.size // 2 + (sign * x)
        # Check whether the point go out of the boundary
        if x < 0 or x >= self.size or y >= self.size:
            return [-1, -1]
        return [x, y]

    def __save(self) -> None:
        '''
        Save the current map for visualization.
        '''
        if self.all_maps is None:
            self.all_maps = np.expand_dims(self.map, axis=0)
        else:
            self.all_maps = np.vstack((self.all_maps, np.expand_dims(self.map, axis=0)))
